using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Game.Editor
{
    public class GameResourcesGenerator : AssetPostprocessor
    {
        private const string ResourcesFolderPath = "_Game/Resources";
        private const string OutputDirectory = "_Game/Scripts/Runtime/Generated/";
        private const string DefaultOutputClassName = "GameResources";
        
        private static readonly HashSet<string> CSharpKeywords = new()
        {
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
            "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
            "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
            "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
            "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
            "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short",
            "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true",
            "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual",
            "void", "volatile", "while"
        };

        private static readonly Dictionary<string, string> ExtensionToTypeMap = new(StringComparer.OrdinalIgnoreCase)
        {
            {".prefab", "GameObject"},
            {".txt", "TextAsset"},
            {".json", "TextAsset"},
            {".xml", "TextAsset"},
            {".mp3", "AudioClip"},
            {".wav", "AudioClip"},
            {".ogg", "AudioClip"},
            {".png", "Sprite"},
            {".jpg", "Sprite"},
            {".jpeg", "Sprite"},
            {".mat", "Material"},
            {".shader", "Shader"},
            {".uss", "StyleSheet"},
            {".asset", "ScriptableObject"}
        };

        [MenuItem("Tools/Generate Resources Class", priority = 100)]
        public static void GenerateResourceClass()
        {
            try
            {
                var resourcesPath = Path.Combine(Application.dataPath, ResourcesFolderPath);
                if (!Directory.Exists(resourcesPath))
                {
                    Debug.LogError($"Resources folder not found at path: {resourcesPath}");
                    return;
                }

                var outputDirectory = Path.Combine(Application.dataPath, OutputDirectory);
                Directory.CreateDirectory(outputDirectory);

                var outputPath = Path.Combine(outputDirectory, $"{DefaultOutputClassName}.cs");
                var isNewFile = !File.Exists(outputPath);

                var namespaces = new HashSet<string> { "UnityEngine", "UnityEngine.UIElements" };
                var classContent = BuildClassContent(resourcesPath, namespaces);
                var fileContent = BuildFileContent(namespaces, classContent);

                File.WriteAllText(outputPath, fileContent);

                if (isNewFile)
                {
                    AssetDatabase.Refresh();
                    Debug.Log($"Successfully generated {DefaultOutputClassName} class at: {outputPath}");
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"Failed to generate resources class: {ex.Message}");
            }
        }

        private static string BuildFileContent(HashSet<string> namespaces, string classContent)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("//------------------------------------------------------------------------------");
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by a tool.");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("//------------------------------------------------------------------------------");
            sb.AppendLine();
            
            // Namespaces
            foreach (var ns in namespaces.OrderBy(n => n))
            {
                sb.AppendLine($"using {ns};");
            }
            
            sb.AppendLine();
            sb.Append(classContent);
            
            return sb.ToString();
        }

        private static string BuildClassContent(string rootPath, HashSet<string> namespaces)
        {
            var sb = new StringBuilder();
            
            
            sb.AppendLine("namespace Game.Runtime.CMS");
            sb.AppendLine("{");
            sb.AppendLine($"    public static class {DefaultOutputClassName}");
            sb.AppendLine("    {");
            
            ProcessDirectory(rootPath, sb, "        ", namespaces);
            
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void ProcessDirectory(string directoryPath, StringBuilder sb, string indent, HashSet<string> namespaces)
        {
            // Process subdirectories first
            foreach (var subDir in Directory.GetDirectories(directoryPath).OrderBy(d => d))
            {
                var dirName = SanitizeIdentifier(Path.GetFileName(subDir));
                sb.AppendLine($"{indent}public static class {dirName}");
                sb.AppendLine($"{indent}{{");
                ProcessDirectory(subDir, sb, indent + "    ", namespaces);
                sb.AppendLine($"{indent}}}");
            }

            // Then process files
            foreach (var file in Directory.GetFiles(directoryPath).OrderBy(f => f))
            {
                var fileName = Path.GetFileNameWithoutExtension(file);
                if (string.IsNullOrEmpty(fileName)) continue;

                var sanitizedName = SanitizeIdentifier(fileName);
                var relativePath = GetResourceRelativePath(file);
                var assetType = GetAssetType(file, relativePath, namespaces);

                if (!string.IsNullOrEmpty(assetType))
                {
                    sb.AppendLine($"{indent}public static {assetType} {sanitizedName} => Resources.Load<{assetType}>(\"{relativePath}\");");
                }
            }
        }

        private static string GetAssetType(string filePath, string relativePath, HashSet<string> namespaces)
        {
            var extension = Path.GetExtension(filePath);
            
            if (ExtensionToTypeMap.TryGetValue(extension, out var assetType))
            {
                if (extension.Equals(".prefab", StringComparison.OrdinalIgnoreCase))
                {
                    var componentType = GetPrefabComponentType(relativePath, namespaces);
                    return string.IsNullOrEmpty(componentType) ? assetType : componentType;
                }
                
                return assetType;
            }

            return null;
        }

        private static string GetPrefabComponentType(string relativePath, HashSet<string> namespaces)
        {
            var fullPath = $"Assets/{ResourcesFolderPath}/{relativePath}.prefab";
            var prefab = AssetDatabase.LoadAssetAtPath<GameObject>(fullPath);
            
            if (prefab == null)
            {
                Debug.LogError($"Prefab not found: {fullPath}");
                return null;
            }

            foreach (var component in prefab.GetComponents<Component>())
            {
                if (component is MonoBehaviour monoBehaviour)
                {
                    var type = monoBehaviour.GetType();
                    if (!string.IsNullOrEmpty(type.Namespace))
                    {
                        namespaces.Add(type.Namespace);
                    }
                    return type.Name;
                }
            }

            return null;
        }

        private static string SanitizeIdentifier(string input)
        {
            if (string.IsNullOrEmpty(input))
                return "_empty";

            var sb = new StringBuilder(input.Length);
            var firstChar = input[0];

            // Handle first character
            if (char.IsDigit(firstChar))
            {
                sb.Append('_');
            }
            else if (!char.IsLetter(firstChar) && firstChar != '_')
            {
                sb.Append('_');
            }

            // Process remaining characters
            foreach (var c in input)
            {
                sb.Append(char.IsLetterOrDigit(c) ? c : '_');
            }

            var result = sb.ToString();
            return CSharpKeywords.Contains(result) ? $"@{result}" : result;
        }

        private static string GetResourceRelativePath(string fullPath)
        {
            var resourcesIndex = fullPath.IndexOf("Resources", StringComparison.Ordinal);
            if (resourcesIndex == -1)
            {
                Debug.LogError($"Resources folder not found in path: {fullPath}");
                return null;
            }

            var relativePath = fullPath.Substring(resourcesIndex + "Resources".Length + 1);
            return Path.ChangeExtension(relativePath, null).Replace('\\', '/');
        }
    }
}